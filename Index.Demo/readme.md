Проблемы синхронизации с файловой системой
==========================================

Наблюдение за папкой, которой нет
---------------------------------

Нельзя запустить наблюдение `FileSystemWatcher` за папкой, которой нет на диске.

### Решение

Периодически проверять путь, и если папка появилась, начинать наблюдение.

Переименование папки, за которой наблюдает FileSystemWatcher
------------------------------------------------------------

Cобытия переименования нет, что соотвествует документации, но нет и события 
`FileSystemWatcher.Error`. После переименования он начинает возвращать неправильные пути к 
изменённым файлам, как если бы переименования не было.

### Решение

Периодический мониторинг пути к открытой в `FileSystemWatcher` папке. Если переименование 
обнаружено, `FileSystemWatcher` выключаем, считаем что наблюдаемую папку удалили. См. метод 
`WatcherPathInspector.GetActualPath`.

Доступ других процессов к сканируемой папке
-------------------------------------------

Иногда нужно просканировать папку на наличие подпапок и файлов. Например, после того, как мы 
начинаем следить за папкой.

Проверено вручную, с помощью Windows Explorer, что в процессе выполнения 
`DirectoryInfo.EnumerateFiles` и `DirectoryInfo.EnumerateDirectories`, папку можно свободно удалить 
и создать на её месте новую. Выполнение методов EnumerateXXX не прерывается, файлы и папки 
продолжают возвращаться нормально, вероятно это связано с буферизацией в EnumerateXXX методах.

В обнаружении "фиктивных" папок и файлов нет ничего страшного, так как в конце концов их удаление
будет обнаружено и обработано. Тем не менее

### Решение

Чтобы по возможности избегать сканирования удалённых / перемещённых папок, операции сканирования 
сделаны как можно более короткими. С этой целью одиночные операции выполняются не рекурсивно, 
перечисление файлов и подпапок происходят как две отдельные операции.

Доступ других процессов к сканируемому файлу
--------------------------------------------

Хочется как можно меньше вмешиваться в работу других процессов с файлами, которые мы сканируем, 
поэтому открываем файлы с `FileShare.Read|Write|Delete`.

Однако, этого недостаточно:

1. Другие процессы не могут открыть файл без `FileShare.Read`, например с `FileShare.Write`.
2. Другие процессы могут удалить файл, но фактическое удаление не происходит до закрытия последнего
дескриптора файла, то есть до окончания сканирования. При попытке повторно создать якобы удалённый
файл, сторонний процесс получает `UnauthorizedAccessException`.

### Решение

1. Не вижу как решить кардинально. Смягчить остроту можно индексируя ограниченными порциями, чтобы
хозяин за короткое время смог снова получить доступ к файлу. В тестовом задании не реализовано.
Настройка по-умолчанию ограничивает размер индексируемого файла 64Mb, что делить на более мелкие 
порции не сильно поможет.

2. Проблема решена с использованием NTFS HardLink. Перед чтением файла создаётся HardLink во 
временной папке. После завершения сканирования HardLink удаляется. Если сторонний процесс удаляет
файл в его исходном местоположении, мы обнаруживаем это с помощью FileSystemWatcher и прерываем
процесс индексации. В отличных от NTFS файловых системах проблема не решена.

Сканирование файла, который часто меняется
------------------------------------------

### Решение

Введена величина `ThrottlingDelay`, которая обозначает минимальный период времени, который с файлом
ничего не должно происходить, чтобы мы начали его сканировать. Если что-то происходит до истечения 
`ThrottlingDelay`, мы откладываем задачу.

Вдруг мы сканируем не тот файл?
-------------------------------

Так как есть отставание модели структуры папок в оперативной памяти `Mirror` от реального положения 
дел на диске, как мы можем быть уверены, что мы прочитаем при индексации нужный файл, а на быстро 
возникшего его месте тёзку?

### Решение

Введена величина `AllowablePathSynchronizationLag`. Это взятая с запасом величина отставания, 
которую, как мы считаем, может иметь `Mirror`. Когда мы обнаруживаем перемещение файла, который мы 
только что закончили индексировать, то есть прошло меньше чем `AllowablePathSynchronizationLag`, то
мы ставим задачу на переиндексацию перемещённого файла.

В противном случае, мы просто отмечаем в `Mirror` изменившийся путь к файлу, содержимое файла 
считаем ранее проиндексированным верно.

Вдруг мы сканируем не ту папку?
-------------------------------

### Решение

Аналогично предыдущему пункту. Если перемещена давно проиндексированная папка, мы считаем, что у нас
полная информация о её содержимом. Мы только отмечаем изменившийся путь папки в `Mirror`.

Иначе, мы ставим задачу на повторное сканирование (обновление списка подпапок и файлов) папки.



Проблемы индексации
===================

Что такое слово
---------------

В подавляющем большинстве языков слова разделены пробелами или чем-то ещё. Но это не относится к 
китайскому и японскому (хотя относится к корейскому) языкам. В японском, помимо иероглифов, есть 
слоговая азбука, но даже при записи в ней, пробелы не являются обязательными.

### Решение

`DefaultLexer` считает иероглифы китайского и японского отдельными словами. Запрос `火垂る` считается
эквивалентным запросу `"火 垂 る"`, то есть запросу фразы.

Индексация файлов индекса
-------------------------

### Решение

Возможность такой ситуации явным образом учтена в коде `IndexingTaskProcessor`. Индексации файлов 
внутри папки индекса не происходит.

Обработка запроса отрицания на языке Lucene
-------------------------------------------

Запрос чистого отрицания, например `NOT war` парсится без ошибок, но при выполнени даёт пустое 
множество, что некорректно.

### Решение

Обработка запроса перед выполнением. `NOT war` будет заменён на эквивалент `*:* AND NOT war`, где
`*:*` это так называемый `MatchAllDocumentsQuery`. Такой запрос будет выполнен корректно, хотя и 
потребует полного сканирования индекса.

Чтобы потребитель библиотеки индексирования мог избегать полного сканирования, объект разобранного 
запроса `IQuery` содержит список `Warnings`, который потребитель может проверить перед выполнением 
запроса. В текущей реализации Warning создаётся только при наличии в запросе чисто отрицательных 
подзапросов наподобие `NOT war`.

Примечание: Запросам с постфиксом `*war` свойственна та же проблема полного сканирования индекса.
`Warning` на такие запросы также был реализован.

Копирование и вставка в строку поиска
-------------------------------------

В языке запросов Lucene поисковый запрос `мама мыла раму` эквивалентен `мама OR мыла OR раму`.
Чаще всего, при вставке в запрос фразы, мы хотим искать её целиком и с учётом близости и порядка 
следования слов, что в синтаксисе Lucene достигается кавычками `"мама мыла раму"`.

### Решение

При вставке в строку поиска текста из буфера обмена, несколько слов обрамляются кавычками.

Обратная проблема - копирование и вставка из строки поиска в строку поиска с учётом предыдущего 
пункта. Текст в строке поиска написан уже с учётом синтаксиса Lucene, предобработки при вставке быть 
не должно. 

Чтобы достичь этого, при копировании текста из строки поиска, к нему добавляется префикс `search: `. 
При вставке с таким префиксом, он отбрасывается, а предобработки не происходит.



Что не успел
============

Оптимальная обработка перемещения (не переименования) файлов и папок
--------------------------------------------------------------------

FileSystemWatcher для перемещённых папок / файлов генерирует 2 события `Deleted`, `Created`, но не 
`Renamed`. Из за этого нам приходится повторно сканировать файлы, содержимое которых не менялось.

### Решение (возможное)

Реализовать и протестировать уже не успеваю, но опишу способ, которым можно обойти эту проблему.
NTFS позволяет хранить для файлов "альтернативные потоки данных", Alternate Data Stream. На этом 
механизме, в частности, основано хранение расширенных атрибутов файлов NTFS.

С помощью тестов удалось убедиться в возможности записать и прочесть данные в такой поток.

Таким образом, у нас есть возможность прикреплять к проиндексированному файлу некую "метку", которая 
будет оставаться с ним при любых операциях копирования / перемещения в пределах файловых систем 
NTFS.

Я бы писал в такую метку LastWriteTime проиндексированного файла и идентификатор содержимого 
`ContentId`, с помощью которого `Mirror` идентифицирует неизменное содержимое файла.

Побочные выгоды:

- Появится возможность избегать переиндексации не только при операциях перемещения файла, но и 
копирования.

- Появится возможность после перезапуска индекса не переиндексировать файлы, которые не менялись, 
так как сам индекс в текущей реализации хранится на диске и может пережить перезапуск.

Удаление наблюдаемых папок и файлов "на лету"
---------------------------------------------

Добавление на лету реализовано, но чтобы что-то убрать, придется запустить новый `IndexFacade` с 
изменённым списком наблюдаемых папок / файлов.

Изменение фильтра имён индексируемых файлов "на лету"
-----------------------------------------------------

Чтобы изменить фильтр, придётся запустить запустить новый `IndexFacade`.

Сканирование больших файлов порциями
------------------------------------

Чтобы хозяин файла, который пытается открыть его с `FileShare.Write`, мог перехватить доступ к файлу
как можно быстрее. См. раздел "Доступ других процессов к сканируемому файлу"
